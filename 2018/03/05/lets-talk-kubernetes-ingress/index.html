<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="map[]"><meta name=description content="A Technical Blog"><link rel=apple-touch-icon sizes=180x180 href=https://blog.komoro.ski/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://blog.komoro.ski/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://blog.komoro.ski/favicon-16x16.png><link rel=manifest href=https://blog.komoro.ski//site.webmanifest><title>Let's Talk Kubernetes Ingress</title><meta name=generator content="Hugo 0.75.1"><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css integrity=sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u crossorigin=anonymous><link rel=stylesheet type=text/css href=https://blog.komoro.ski/css/main.css><link rel=stylesheet type=text/css href=https://use.fontawesome.com/releases/v5.0.6/css/all.css><link rel=stylesheet type=text/css href=https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css><link rel=stylesheet type=text/css href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,400,200bold,400old"><!--[if lt IE 9]><script src=https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js></script><script src=https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js></script><![endif]--></head><body><div id=wrap><nav class="navbar navbar-default"><div class=container><div class=navbar-header><a class=navbar-brand href=https://blog.komoro.ski/><i class="fa fa-home"></i></a></div><div id=navbar><ul class="nav navbar-nav navbar-right"><li><a href=/blog/>BLOG</a></li><li><a href=/projects/>PROJECTS</a></li><li><a href=/about/>ABOUT</a></li></ul></div></div></nav><div class=container><div class=blog-post><h3><strong><a href=https://blog.komoro.ski/2018/03/05/lets-talk-kubernetes-ingress/>Let's Talk Kubernetes Ingress</a></strong></h3></div><div class=blog-title><h4>March 5, 2018
&nbsp;&nbsp;
<span class="label label-success">kubernetes</span>
<span class="label label-success">homelab</span>
<span class="label label-success">config</span></h4></div><div class="panel panel-default"><div class=panel-body><div class=blogpost><p>If you don&rsquo;t know what <a href=https://kubernetes.io/>Kubernetes</a> is, I highly suggest to look into it. It&rsquo;s a container orchestration system that runs anywhere. In short, it takes the simple but powerful concept of a containerized application (popularized by <a href=https://www.docker.com/what-docker>docker</a>), and ramps it up to web scale levels. It allows you to deploy and manage hundreds or thousands of contaners without the pain of managing the VM and OS layers assocated with a normal
deployment. But the purpose of this post is not to preach container orchestration. My goal here is to get more tactical about the topic and talk about a specific component of Kubernetes called an Ingress Controller.</p><p>When I first started tinkering with my cluster, the most difficult piece of understanding what was going on was networking. Getting traffic into my cluser was not obvious from the start. There are some simple things you can set up like NodePort services, or if you&rsquo;re on a cloud provider, you may have access to LoadBalancer services. Since <a href=/2018/02/20/my-lab/>my lab</a> is in my basement, I started with simple NodePort services.</p><p>These worked, especially given the learning curve needed for them. They gave me an easy win where I could get started without having to learn everything. Below is an example Nginx Replication Controller, accessable via a node port service:</p><pre><code>---
apiVersion: v1
kind: ReplicationController
metadata:
  name: nginx
spec:
  # Number of pods to run
  replicas: 3
  selector:
    app: nginx
  template:
    metadata:
      name: nginx
      labels:
        app: nginx
    spec:
      # What container(s) will run in each pod
      containers:
      - name: nginx
        image: nginx
        ports:
        - containerPort: 80
---
apiVersion: v1
kind: Service
metadata:
  labels:
    name: nginxservice
  name: nginxservice
spec:
  ports:
      # The port that this service should serve on within the cluster
    - port: 80
      # The destination port that traffic will go to at the pod 
      targetPort: 80
      # The port that the service will be accessed from outside the cluster at the node's ip
      nodePort: 31000
  # Label keys and values that must match in order to receive traffic for this service.
  selector:
    app: nginx
  type: NodePort
</code></pre><p>This sort of thing works, but if you want to route traffic directly to the cluster, you&rsquo;d need to route traffic to a non-standard port. Also, what if you want to host multiple sites from your cluster, it would require you to stand up a reverse proxy to address. This is where ingress controllers enter. If you want to route based on path, or a host header ingress rules and a controller can make this very easy.</p><p>There are several applications that can act as a kubernetes ingress controller, Nginx, HAProxy, Rancher, Traefik and many more can all serve this purpose. In my lab, I&rsquo;m runing <a href=https://traefik.io/>Traefik</a> as my ingress controller. I like that it&rsquo;s a very small containter with all the bells and whistles. To deploy it to my lab, I just needed to apply the following file to my cluster:</p><pre><code>---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: traefik-ingress-controller
  namespace: kube-system
---
kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1beta1
metadata:
  name: traefik-ingress-controller
rules:
  - apiGroups:
      - &quot;&quot;
    resources:
      - services
      - endpoints
      - secrets
    verbs:
      - get
      - list
      - watch
  - apiGroups:
      - extensions
    resources:
      - ingresses
    verbs:
      - get
      - list
      - watch
---
kind: ClusterRoleBinding
apiVersion: rbac.authorization.k8s.io/v1beta1
metadata:
  name: traefik-ingress-controller
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: traefik-ingress-controller
subjects:
- kind: ServiceAccount
  name: traefik-ingress-controller
  namespace: kube-system
---
apiVersion: extensions/v1beta1
kind: DaemonSet
metadata:
  name: traefik-daemonset
  namespace: kube-system
  labels:
    k8s-app: traefik-ingress-lb
spec:
  template:
    metadata:
      labels:
        k8s-app: traefik-ingress-lb
        name: traefik-ingress-lb
    spec:
      serviceAccountName: traefik-ingress-controller
      terminationGracePeriodSeconds: 60
      hostNetwork: true
      containers:
      - image: traefik
        name: traefik-ingress-lb
        ports:
        - name: http
          containerPort: 80
          hostPort: 80
        - name: https
          containerPort: 443
          hostPort: 443
        - name: admin
          containerPort: 8080
        securityContext:
          privileged: true
        args:
        - --api
        - --kubernetes
</code></pre><p>This sets up the role, role binding, account and the daemonset for the application. With that, you would be ready to start setting up ingress rules, and routes as you see fit. In my cluster, I want to be able to see the Traefik web ui. So Lets set up an ingress and service to the Traefik application itself.</p><pre><code>---
apiVersion: v1
kind: Service
metadata:
  name: traefik-web-ui
  namespace: kube-system
spec:
  selector:
    k8s-app: traefik-ingress-lb
  ports:
  - port: 80
    targetPort: 8080
---
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: traefik-web-ui
  namespace: kube-system
  annotations:
    kubernetes.io/ingress.class: traefik
spec:
  rules:
  - host: traefik.mydomain.tld
    http:
      paths:
      - backend:
          serviceName:  traefik-web-ui
          servicePort: 80
</code></pre><p>This defines a service for the traefik UI (serice port 80, container port 8080). It then defines an ingress rule that the controller will use to define an inbound route. In this case it&rsquo;s a reverse proxy rule, that takes the inbound traffic with a host header &ldquo;traefik.mydomain.tld&rdquo; and sends it to the traefik-web-ui on port 80. If you have a dns record (or hostfile entry) that points your browser to the cluster host IP, you&rsquo;ll get the following:</p><img src=/img/traefik_ingress_ui.png alt=Traefik_UI style=width:750px><p>And there you have it. A quick intro to Kubernetes Ingress!</p><hr><div class=related-posts><h5>Related Posts</h5><div class=row><div class="col-sm-4 col-md-4 col-lg-4"><h6 style=text-align:right>January 4, 2021</h6></div><div class="col-sm-8 col-md-8 col-lg-8"><h6 style=text-align:left><strong><a href=/2021/01/04/improving-my-network-static-hosting-and-reverse-proxy-with-caddy/>Improving My Network: Static Hosting and Reverse Proxy with Caddy</a></strong></h6></div></div><div class=row><div class="col-sm-4 col-md-4 col-lg-4"><h6 style=text-align:right>January 1, 2021</h6></div><div class="col-sm-8 col-md-8 col-lg-8"><h6 style=text-align:left><strong><a href=/2021/01/01/improving-my-network-public-proxy-and-wireguard-vpn/>Improving My Network: Public Proxy and Wireguard VPN</a></strong></h6></div></div><div class=row><div class="col-sm-4 col-md-4 col-lg-4"><h6 style=text-align:right>December 22, 2020</h6></div><div class="col-sm-8 col-md-8 col-lg-8"><h6 style=text-align:left><strong><a href=/2020/12/22/improving-my-network-domains-and-dns/>Improving My Network: Domains and DNS</a></strong></h6></div></div></div></div></div><hr><div class=disqus><div id=disqus_thread></div><script type=text/javascript>!function(){var b,a;if(window.location.hostname=="localhost")return;b='kasualkomoroski',a=document.createElement('script'),a.type='text/javascript',a.async=!0,a.src='//'+b+'.disqus.com/embed.js',(document.getElementsByTagName('head')[0]||document.getElementsByTagName('body')[0]).appendChild(a)}()</script><noscript>Please enable JavaScript to view the <a href=http://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=http://disqus.com/ class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></div></div></div><footer><div id=footer><div class=container><p class=text-muted>&copy; Jared Komoroski. All rights reserved. Powered by <a href=https://gohugo.io/>Hugo</a> and
<a href=http://www.github.com/nurlansu/hugo-sustain/>sustain</a> with ♥</p></div></div></footer><div class=footer></div><script src=https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js></script><script src=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js integrity=sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa crossorigin=anonymous></script><script src=https://blog.komoro.ski/js/docs.min.js></script><script src=https://blog.komoro.ski/js/main.js></script><script src=https://blog.komoro.ski/js/ie10-viewport-bug-workaround.js></script></body></html>