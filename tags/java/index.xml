<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>java on Kasual Komoroski</title><link>https://blog.komoro.ski/tags/java/</link><description>Recent content in java on Kasual Komoroski</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 01 Dec 2020 17:16:39 -0700</lastBuildDate><atom:link href="https://blog.komoro.ski/tags/java/index.xml" rel="self" type="application/rss+xml"/><item><title>Junit 5 Composed Annotations</title><link>https://blog.komoro.ski/2020/12/01/junit-5-composed-annotations/</link><pubDate>Tue, 01 Dec 2020 17:16:39 -0700</pubDate><guid>https://blog.komoro.ski/2020/12/01/junit-5-composed-annotations/</guid><description>Junit 5 uses an extension system to support code reuse and clean code patterns. An important part of this is being able to register test extensions declaratively. Extension declarations can become quite cumbersome if they need to be repeated over and over again. For example:
... @ExtendWith(MyFirstTestExtension.class) @ExtendWith(MySecondTestExtension.class) @ExtendWith(MyRequiredTestExtension.class) @ExtendWith(MyParameterResolver.class) class MyClassTest { @Test void myTestMethod(MyParameter myParam) { assertNotNull(myParam); } } Or:
... @ExtendWith({ MyFirstTestExtension.class, MySecondTestExtension.class, MyRequiredTestExtension.class, MyParameterResolver.class }) class MyClassTest { @Test void myTestMethod(MyParameter myParam) { assertNotNull(myParam); } } If you&amp;rsquo;re working with many test classes, making sure all tests have all the right extensions can become an unwelcome chore &amp;ndash; especially if you&amp;rsquo;re adding and extending a framework and providing that framework as a consumable library.</description></item></channel></rss>